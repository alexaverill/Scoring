
<html manifest="scores.manifest">
	<head>
		<script type="text/javascript" src="source/jquery-2.1.1.min.js"></script>
		<script src="source/jquery.jeditable.js" type="text/javascript"></script>
				<!-- Latest compiled and minified CSS -->
		<link rel="stylesheet" href="source/bootstrap/css/bootstrap.css">
		<!-- Extra Themes -->
		<link rel="stylesheet" href="source/parts.css">
		<!-- Latest compiled and minified JavaScript -->
		<script src="source/bootstrap/js/bootstrap.min.js"></script>
		<script src="source/editing.js"></script>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>Score Sheet</title>
		<script type="text/javascript" src="source/jquery-2.1.1.min.js"></script>
		<script>
			var scores = [];
			var sortMethod = {{SortMethod}}; //1 is a low to high sort, two is a high to low sort.
			var max = {{NumberTeams}};
			var teams_participating = 0;
                        var eventName = "{{EventName}}";
			var teamsToRank = {{TeamsToRank}};
			var connection = true;
			//var teamsToRank = 3;
			// [[row,score,tier,tieplace,tie]]
			//for x<max totalPlacement.push([])
			//var totalPlacement = [[],[],[],[],[],[]];
			var totalPlacement = [];
			var finalPlacement = [];
			function create_total_placement(){
				var emptyArray =[];
				for(x=0;x<max;x++){
					//create array, and populate number of rows
					totalPlacement[x] = [3]; //create an array of three at each pount
					
					totalPlacement[x][0] = x+1;	//add the row index for the table
					totalPlacement[x][3] =0; //set default to false for ties
					totalPlacement[x][4] = 0; //det default place for ties to 0.
				}
				
			}
			function add_rows_to_array() {
				//loop through and add the row number, first thing to do. part of creation of the array?
				for(x=0;x<max;x++){
					totalPlacement[x][0]=x+1;
				}
			}
			function save_score_to_cell(scoreNum,schoolName,tiePlace,placeR,tierR) {
			    $.ajax({
					type: "POST",
					url: "bridges/individualscores.php",
					data: { event: eventName, score: scoreNum,school:schoolName,placeInTie:tiePlace,place: placeR,tier: tierR }
					})
					.done(function( msg ) {
					    if (msg.length>0) {
						document.getElementById('locked').innerHTML = 'This Event has been submitted, and is now Locked';
					    
					    }
					});
				}
			
			function saveScores(){
			    //saves scores into localStorage, removed option to save to database, really not needed?
				localStorage.setItem(eventName, JSON.stringify(totalPlacement));
				//send raw scores across to be stored.
				/*$.ajax({
					type: "POST",
					url: "bridges/save.php",
					data: { event: eventName, scores: JSON.stringify(totalPlacement)  }
					})
					.done(function( msg ) {
					if (msg.length>0) {
					    document.getElementById('locked').innerHTML = 'This Event has been submitted, and is now Locked';
					
					}
					});*/
				
			}
			function loadScores() {
				totalPlacement = JSON.parse(localStorage.getItem(eventName));
				for (z=0;z<max;z++) {
					row = totalPlacement[z][0];
					score = totalPlacement[z][1];
					tier = totalPlacement[z][2];
					scoreLoc = (z+1)+'score';
					tierLoc = (z+1)+'tier';
					//console.log(scoreLoc);
					document.getElementById(scoreLoc).value=score;
					document.getElementById(tierLoc).value=tier;
					/*editableGrid.setValueAt(row-1,1,score,true);
					editableGrid.setValueAt(row-1,2,tier,true);*/
				}
			}
			function compareScores(a,b) {
				//if sort method is set to 2 for a high to low sort it will return that, otherwise defualts to low to high
					if (sortMethod == 2) {
						return parseFloat(b[1]) - parseFloat(a[1]);
					}else{
						
						return parseFloat(a[1]) - parseFloat(b[1]);
					}
					
				}
			function compareties(a,b) {
				//if sort method is set to 2 for a high to low sort it will return that, otherwise defualts to low to high
					if (sortMethod == 2) {
						return parseFloat(b[4]) - parseFloat(a[4]);
					}else{
						return parseFloat(a[4]) - parseFloat(b[4]);
					}
					
				}
			function ranking(){
				//function to take all scores and rank them, start by sorting them into tier arrays, tier one two and three
				//then sort each array based on final score, then merge back into the totalPlacement Array.
				//tier arrays.
				var one = [];
				var two = [];
				var three = [];
				var four = [];
                                var NS = [];
                                var DQ = [];
                                var P =[];
				teams_participating = 0;
				check_all_ties();
				for (x=0; x<max; x++) {
				    if (totalPlacement[x][1] != 0 && totalPlacement[x][1] != "") {
					//update number of teams participating
					
					if (totalPlacement[x][1] == "P" || totalPlacement[x][1] == "p" ) {
						totalPlacement[x][1] = "P"; //edit to capitalization to make rest of code work.
					    P.push(totalPlacement[x]);
					teams_participating ++;
					}else if(totalPlacement[x][1] == "NS" || totalPlacement[x][1] == "ns"){
						totalPlacement[x][1] = "NS";
					    NS.push(totalPlacement[x]);
					   
					}else if(totalPlacement[x][1] == "DQ" || totalPlacement[x][1] == "dq"){
						totalPlacement[x][1] = "DQ";
					    DQ.push(totalPlacement[x]);
					    teams_participating ++;
					}else if (totalPlacement[x][2]==1) {
						one.push(totalPlacement[x]);
						teams_participating ++;
					}else if (totalPlacement[x][2]==2) {
						two.push(totalPlacement[x]);
						teams_participating ++;
					}else if (totalPlacement[x][2]==3) {
						three.push(totalPlacement[x]);
						teams_participating ++;
					}else if (totalPlacement[x][2]==4) {
						four.push(totalPlacement[x]);
						teams_participating ++;
					}else{
						//error
					}
				    }else if (totalPlacement[x][1] == "") {
						//remove any place if applicable.
						row = totalPlacement[x][0];
						Srow = row+'place';
						if (document.getElementById(Srow)) {
							document.getElementById(Srow).innerHTML = "";
						}
				    }
					
				}
				
				//sort based on teirs
				one.sort(compareScores);
				two.sort(compareScores);
				three.sort(compareScores);
				four.sort(compareScores);
				//clear old array;
				finalPlacement.length=0;
				//build final place array
				for(x=0;x<one.length;x++){
					finalPlacement.push(one[x]);
				}
				for(x=0;x<two.length;x++){
					finalPlacement.push(two[x]);
				}
				for(x=0;x<three.length;x++){
					finalPlacement.push(three[x]);
				}
				for(x=0;x<four.length;x++){
					finalPlacement.push(four[x]);
				}
				for(x=0;x<P.length;x++){
					finalPlacement.push(P[x]);
				}
				for(x=0;x<NS.length;x++){
					finalPlacement.push(NS[x]);
				}
				for(x=0;x<DQ.length;x++){
					finalPlacement.push(DQ[x]);
				}
				for(y=0;y<finalPlacement.length;y++){
					//check ties, if there is a tie skip and put in the ti
					rowLocal = finalPlacement[y][0];
					//tie = check_tie(x);
					//tie = check_all_ties(finalPlacement[y][1],finalPlacement[y][2]);
					if (teamsToRank == 0) {
					    if (finalPlacement[y][1] == "P") {
						placeValue = teams_participating+1; //have to increment to keep it correct
					    }else if (finalPlacement[y][1] == "NS") {
						if (teamsToRank == 0) {
							placeValue = max + 1; // have to have it be one more then P
						}else{
							placeValue = teamsToRank + 1;
						}
						
					    }else if (finalPlacement[y][1]=="DQ") {
						placeValue = max +2;
					    }else if(finalPlacement[y][2] == 2){
						placeValue = y+1;
					    }else if(finalPlacement[y][2] == 3){
						placeValue = y+1;
					    }else if(finalPlacement[y][2] == 4){
						placeValue = y+1;
					    }else{
					       placeValue = y+1; 
					    }
					}else{
					    if (finalPlacement[y][1] == "P") {
						placeValue = teamsToRank+1; //have to increment to keep it correct
					    }else if (finalPlacement[y][1] == "NS") {
						placeValue = teamsToRank +2; // have to have it be one more then P
					    }else if (finalPlacement[y][1]=="DQ") {
						placeValue = max +2;
					    }else{
					       if (y+1<= teamsToRank) {
						placeValue = y+1; 
					       }else{
						placeValue = teamsToRank;
					       }
					       
					    }
					}

					placeLocat = rowLocal+"place";
					//console.log(tie);
					if (finalPlacement[y][3] == 0) {
						//console.log(finalPlacement[y][1]);
						tieDialoglocat = rowLocal +"tie";
						name = document.getElementById(finalPlacement[y][0]).innerHTML;
						//console.log(name);
						document.getElementById(tieDialoglocat).innerHTML = "";
						document.getElementById(placeLocat).innerHTML = placeValue;
						placeInTie = finalPlacement[y][4];
						row = 'R'+rowLocal;
						document.getElementById(row).className = 'normal';
						save_score_to_cell(finalPlacement[y][1],name,placeInTie,placeValue,finalPlacement[y][2]);
					}else{
					    //in tie and not tie broken
					    
						tieDialoglocat = rowLocal +"tie";
						row = 'R'+rowLocal;
						 if (finalPlacement[y][4] == 0 && finalPlacement[y][3]==1) {
						    htmlString ='Place in Tie:<select name="'+rowLocal+'" id="'+rowLocal+'tieselect"class=ties><option></option>';
						    for(v=1;v<=max;v++){
							if (finalPlacement[y][4] == v) {
							    htmlString +='<option value="'+v+'" selected=selected>'+v+'</option>';
							}else{
							    htmlString +='<option value="'+v+'">'+v+'</option>';
							}
						    }
						    htmlString += '</select>'
						    document.getElementById(tieDialoglocat).innerHTML =htmlString;
						    document.getElementById(placeLocat).innerHTML = "tie";
						    name = document.getElementById(finalPlacement[y][0]).innerHTML;
						    document.getElementById(row).className = 'red';
 						    save_score_to_cell(finalPlacement[y][1],name,0,0,finalPlacement[y][2]);
						    
						}else{
						    //Tie and tie broken.
						    htmlString ='Place in Tie:<select name="'+rowLocal+'" id="'+rowLocal+'tieselect"class=ties><option><option>';
						    for(v=1;v<=max;v++){
							if (finalPlacement[y][4] == v) {
							    htmlString +='<option value="'+v+'" selected=selected>'+v+'</option>';
							}else{
							    htmlString +='<option value="'+v+'">'+v+'</option>';
							}
						    }
						    htmlString += '</select>'
						    document.getElementById(tieDialoglocat).innerHTML =htmlString;
						    //document.getElementById(tieDialoglocat).innerHTML = finalPlacement[y][4];
						    
						    tieScore = finalPlacement[y][1];
						    tiePlace = 0;
						    for (u=0; u<finalPlacement.length;u++) {
							if (tieScore == finalPlacement[u][1] ) {
							    tiePlace = u;
							    break;
							}
						    }
						    //placeValue=parseInt(tiePlace) + parseInt(finalPlacement[y][4])
						    updateTiePlace = parseInt(tiePlace) + parseInt(finalPlacement[y][4]);
						    if (teamsToRank !=0) {
							if (updateTiePlace < teamsToRank ) {
							    finalTiePlace = updateTiePlace;
							}else{
							    finalTiePlace = teamsToRank;
							}
						    }else{
							finalTiePlace = updateTiePlace;
						    }
						    document.getElementById(placeLocat).innerHTML = finalTiePlace;
						    name = document.getElementById(finalPlacement[y][0]).innerHTML;
						    document.getElementById(row).className = 'blue';
						    placeInTie = finalPlacement[y][4];
						    save_score_to_cell(finalPlacement[y][1],name,placeInTie,placeValue,finalPlacement[y][2]);
						}

					}
					
					
				}
				saveScores();
			
			}
				function check_all_ties(){
					currentScores = [];
					currentTiers = [];
					
					//add scores to current List;
					/*firstIndex = currentScores.indexOf(value);
					lastIndex = currentScores.lastIndexOf(value);
					if (value == 0 || value == 'P' || value == 'DQ' || value == 'NS' ) {
						return false;
					}
					if ( firstIndex == lastIndex ) {
						//if it is the same value it cannot be a tie
						return false;
					}
					if (currentTiers[firstIndex] == currentTiers[lastIndex]) {
						if(currentScores[firstIndex] == currentScores[lastIndex]){
							totalPlacement[firstIndex][3] = 1;
							totalPlacement[lastIndex][3]=1;
							return true;
						}
					}*/
					outer=0;
					returnVal = false;
					while(outer<totalPlacement.length){
						inner = 1;
						if ((totalPlacement[outer][1] == ""
						     || totalPlacement[outer][1] =='P'
						     ||totalPlacement[outer][1] =='p'
						     ||  totalPlacement[outer][1] =='DQ'
						     || totalPlacement[outer][1] =='dq'
						     ||  totalPlacement[outer][1] =='NS'
						     ||totalPlacement[outer][1] =='ns')) {
								totalPlacement[outer][3]=0;
						}else{
							while(inner<totalPlacement.length){
								if (totalPlacement[outer][2] == totalPlacement[inner][2]) {
							   
								//the scores are the same which means we could have a tie
									if ((totalPlacement[outer][1] == totalPlacement[inner][1]) && outer != inner) {
									       //console.log(currentTiers[outer]);
									       //console.log(currentTiers[inner]);
									   // the tiers are the same so we have a tie
									   totalPlacement[outer][3]=1;
									   totalPlacement[inner][3]=1; //needed to catch ties of only two
									   //returnVal = true;
								       }
								}else{
									//totalPlacement[outer][3] = 0;
									//totalPlacement[outer][4] =0;
								}
							    inner++;
							}
						}
					    outer++;
					}
					return returnVal;
				}
			function updateTie(locationchange,placeInTie){
				//get scoere
				//console.log(placeInTie)
				scorePlace = locationchange +'score';
				tiePlace = locationchange +"tie"
				originalScore = document.getElementById(scorePlace).value;
				stringAdd = '.0'+placeInTie;
				toAdd = parseFloat(originalScore)+parseFloat(stringAdd);
				//update score
				totalPlacement[locationchange-1][4] = placeInTie;//store the location of place
				//console.log(toAdd); 
				if (placeInTie > teamsToRank ) {
				    toAdd = teamsToRank;
				}
				document.getElementById(tiePlace).innerHTML = toAdd;
				ranking();
				//update_scores();
			}
			function update_scores(scoreIn){
				
				//function to update scores...
				//loop through scores and add them to the array, updating them if nessisary.
				for(x=1; x<=max;x++){
					scorelocation = x+"score";
					tierlocal = x+"tier";
					theScore = document.getElementById(scorelocation).value;
					theTier = document.getElementById(tierlocal).value;
					totalPlacement[x-1][2] = theTier;
					totalPlacement[x-1][3] = 0;
					if (parseFloat(theScore) != 0) {
						totalPlacement[x-1][1] = theScore;
						teams_participating++;
					}
					/*isTie = check_all_ties(totalPlacement[x-1][1],x-1,totalPlacement[x-1][2]);
					if (isTie) {
						if (document.getElementById(x+'ties')) {
							totalPlacement[x-1][3] = document.getElementById(x+'ties').value;
						}
						
					}*/
				}
				saveScores();
				ranking();
			}

			function final_save(){
			    for(x=1; x<max+1;x++){
				scoresL = x+"score";
				tier = x+"tier";
				place = x+"place"
				placeR = document.getElementById(place).innerHTML;
				scoreNum = document.getElementById(scoresL).value;
				
				tierR = document.getElementById(tier).value;
				schoolName=document.getElementById(x).innerHTML;
				 $.ajax({
					type: "POST",
					url: "bridges/individualscores.php",
					    data: { event: eventName, score: scoreNum,school:schoolName,place: placeR,tier: tierR, locked:"1" }
				    })
				    .done(function( msg ) {
					if (msg.length>0) {
					    document.getElementById('locked').innerHTML = 'This Event has been submitted, and is now Locked';
					
					}
					    //alert( "Data Saved: " + msg );
						console.log(msg);
				    });
			    }
			    document.getElementById('locked').innerHTML = 'This Event has been submitted, and is now Locked';
			}
			function showSaved() {
			    document.getElementById('saved').innerHTML = 'Event Has been Saved';
			}
			function removeSaved() {
			     document.getElementById('saved').innerHTML = '';
			}
			var timeoutID;

			function delayedSave() {
			    saveScores();
			  timeoutID = window.setTimeout(showSaved, 500);
			  timeoutID = window.setTimeout(removeSaved, 4000);
			}
			window.onload = function() {
				//see if local storage has a scores array
				//alert(checkNetConnection();
				checkConnection();
				if (localStorage.getItem(eventName)) {
					loadScores();
					update_scores();
				}else{
					create_total_placement();
				}
					
			}
			function supports_html5_storage() {
				try {
				  return 'localStorage' in window && window['localStorage'] !== null;
				} catch (e) {
				  return false;
				}
			}
			function checkConnection(){
			    connectionStatus = checkNetConnection();
			    //connectionStatus = false;
			    warningLocation = "connection";
			    if (!connectionStatus) {
				document.getElementById(warningLocation).className="alert alert-warning";
				document.getElementById(warningLocation).innerHTML = "Currently operating without a connection, data will be saved to the server once connection is restored, please continue to add scores";
				connection = false;
				return false;
			    }else{
				if (!connection) {
				    document.getElementById(warningLocation).className="alert alert-success";
				    document.getElementById(warningLocation).innerHTML = "Connection Restored, data saved.";
				    ranking();
				}
				connection = true;
				return true;
			    }
			}
			function checkNetConnection(){
			    var xhr = new XMLHttpRequest();
			    var file = "http://esus.us/source/dot.png";
			    var r = Math.round(Math.random() * 10000);
			    xhr.open('HEAD', file + "?subins=" + r, false);
			    try {
			     xhr.send();
			     if (xhr.status >= 200 && xhr.status < 304) {
			      return true;
			     } else {
			      return false;
			     }
			    } catch (e) {
			     return false;
			    }
			}
			 $(document).on("change",'.score', function() {
				newScore = $(this).val();
				checkConnection();
				var allowed={"p","P","ns","NS","DQ","dq"};
				if (typeof newScore =="number" || newScore == "" || allowed.contains(newScore)) {
					update_scores(newScore);
					saveScores();
				}else{
					alert("Input must be a number!");
				}
				
			 });
			  $(document).on("change",'.tiers', function() {
				checkConnection();
				update_scores();
				saveScores();
			 });
			 $(document).on("change",'.ties', function() {
				checkConnection();
				rowPlace = $(this).attr('name');
				placeInTie = $("option:selected", this).val();
				//alert(placeInTie);
				updateTie(rowPlace,placeInTie);
			});
		</script>
		
	</head>
	
	<body>
	{%include 'userNav.html'%}	
	<div class="class="container-fluid">
		<h1>{{EventName}}</h1>
		<h2 id="locked"></h2>
		<h2 id="saved"></h2>
		<div id="connection"></div>
		<h3>Event Supervisors, enter your scores, they will be saved automatically.
		Once ALL of your scores are in hit save and submit, then report to score counseling</h3>
		<ul>
		    <li>Ranking:{{TextRank}}</li>
		    <li>1st in tie recieves more favorable rank</li>
		    <li>Tier 1 receives more favorable rank</li>
		    <li>Uses P to designate a participation points only team</li>
		    <li>Use NS to designate a No Show team</li>
		    <li>Use DQ to designate a disqualified team</li>
		</ul>
		<div class="table-responsive">
		<table  class="table table-bordered table-condensed">
			<tr>
				<th>School</th>
				<th>Raw Score</th>
				<th>Tier</th>
				<th>Tie Break</th>
				<th>Place</th>
							</tr>
			{%for team in TeamList%}
                                <tr id="R{{loop.index}}">
					<td id="{{loop.index}}">{{team.teamNumber}} {{team.teamName}}</td>
					<td><input type="text" size="10" name="{{loop.index}}" class="score" id="{{loop.index}}score" /></td>
					<td>
						<select name="1" class="tiers" tabindex="-1" id="{{loop.index}}tier">
							<option value="1">1</option>
							<option value="2">2</option>
							<option value="3">3</option>
							<option value="4">4</option>
						</select>
					</td>
					<td id="{{loop.index}}tie"></td>
					<td id="{{loop.index}}place"></td>
				</tr>
			{%endfor%}	
		</table>
		<button onclick="delayedSave()" class="btn btn-success" >Save</button>
		<button onclick="final_save()"class="btn btn-primary">Save and Submit</button>
		<button onclick="localStorage.clear();location.reload();" class="btn btn-danger">Clear Data</button>
		</div>
	</body>
	
</html>